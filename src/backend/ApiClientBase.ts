//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ApiClientBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl ?? ''
  }

  /**
   * @param body (optional)
   * @return Success
   */
  attendergroupSave(body: AttenderGroup | undefined): Promise<AttenderGroup> {
    let url_ = this.baseUrl + '/attendergroup/save'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAttendergroupSave(_response)
    })
  }

  protected processAttendergroupSave(response: Response): Promise<AttenderGroup> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = AttenderGroup.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<AttenderGroup>(null as any)
  }

  /**
   * @param attenderGroupId (optional)
   * @param userId (optional)
   * @return Success
   */
  attendergroupMemberAdd(
    attenderGroupId: number | undefined,
    userId: number | undefined,
  ): Promise<AttenderGroup> {
    let url_ = this.baseUrl + '/attendergroup/member/add?'
    if (attenderGroupId === null)
      throw new globalThis.Error("The parameter 'attenderGroupId' cannot be null.")
    else if (attenderGroupId !== undefined)
      url_ += 'attenderGroupId=' + encodeURIComponent('' + attenderGroupId) + '&'
    if (userId === null) throw new globalThis.Error("The parameter 'userId' cannot be null.")
    else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAttendergroupMemberAdd(_response)
    })
  }

  protected processAttendergroupMemberAdd(response: Response): Promise<AttenderGroup> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = AttenderGroup.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<AttenderGroup>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  courseSave(body: Course | undefined): Promise<Course> {
    let url_ = this.baseUrl + '/course/save'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSave(_response)
    })
  }

  protected processCourseSave(response: Response): Promise<Course> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = Course.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<Course>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  courseGroupSave(body: CourseGroup | undefined): Promise<CourseGroup> {
    let url_ = this.baseUrl + '/course/group/save'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseGroupSave(_response)
    })
  }

  protected processCourseGroupSave(response: Response): Promise<CourseGroup> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = CourseGroup.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseGroup>(null as any)
  }

  /**
   * @param courseGroupId (optional)
   * @param userId (optional)
   * @return Success
   */
  courseGroupAttenderUserAdd(
    courseGroupId: number | undefined,
    userId: number | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/course/group/attender-user/add?'
    if (courseGroupId === null)
      throw new globalThis.Error("The parameter 'courseGroupId' cannot be null.")
    else if (courseGroupId !== undefined)
      url_ += 'courseGroupId=' + encodeURIComponent('' + courseGroupId) + '&'
    if (userId === null) throw new globalThis.Error("The parameter 'userId' cannot be null.")
    else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseGroupAttenderUserAdd(_response)
    })
  }

  protected processCourseGroupAttenderUserAdd(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<void>(null as any)
  }

  /**
   * @param courseGroupId (optional)
   * @param attenderGroupId (optional)
   * @return Success
   */
  courseGroupAttenderGroupAdd(
    courseGroupId: number | undefined,
    attenderGroupId: number | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/course/group/attender-group/add?'
    if (courseGroupId === null)
      throw new globalThis.Error("The parameter 'courseGroupId' cannot be null.")
    else if (courseGroupId !== undefined)
      url_ += 'courseGroupId=' + encodeURIComponent('' + courseGroupId) + '&'
    if (attenderGroupId === null)
      throw new globalThis.Error("The parameter 'attenderGroupId' cannot be null.")
    else if (attenderGroupId !== undefined)
      url_ += 'AttenderGroupId=' + encodeURIComponent('' + attenderGroupId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseGroupAttenderGroupAdd(_response)
    })
  }

  protected processCourseGroupAttenderGroupAdd(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<void>(null as any)
  }

  /**
   * @param courseGroupId (optional)
   * @param teacherUserId (optional)
   * @return Success
   */
  courseGroupTeacherAssign(
    courseGroupId: number | undefined,
    teacherUserId: number | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/course/group/teacher/assign?'
    if (courseGroupId === null)
      throw new globalThis.Error("The parameter 'courseGroupId' cannot be null.")
    else if (courseGroupId !== undefined)
      url_ += 'courseGroupId=' + encodeURIComponent('' + courseGroupId) + '&'
    if (teacherUserId === null)
      throw new globalThis.Error("The parameter 'teacherUserId' cannot be null.")
    else if (teacherUserId !== undefined)
      url_ += 'teacherUserId=' + encodeURIComponent('' + teacherUserId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseGroupTeacherAssign(_response)
    })
  }

  protected processCourseGroupTeacherAssign(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<void>(null as any)
  }

  /**
   * @param sessionId (optional)
   * @return Success
   */
  courseTeacherSessionGet(sessionId: number | undefined): Promise<CourseSessionListItem> {
    let url_ = this.baseUrl + '/course/teacher/session/get?'
    if (sessionId === null) throw new globalThis.Error("The parameter 'sessionId' cannot be null.")
    else if (sessionId !== undefined)
      url_ += 'sessionId=' + encodeURIComponent('' + sessionId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseTeacherSessionGet(_response)
    })
  }

  protected processCourseTeacherSessionGet(response: Response): Promise<CourseSessionListItem> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = CourseSessionListItem.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSessionListItem>(null as any)
  }

  /**
   * @param courseGroupId (optional)
   * @return Success
   */
  courseStudentGroupSessionsGet(
    courseGroupId: number | undefined,
  ): Promise<CourseSessionListItem[]> {
    let url_ = this.baseUrl + '/course/student/group/sessions/get?'
    if (courseGroupId === null)
      throw new globalThis.Error("The parameter 'courseGroupId' cannot be null.")
    else if (courseGroupId !== undefined)
      url_ += 'courseGroupId=' + encodeURIComponent('' + courseGroupId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseStudentGroupSessionsGet(_response)
    })
  }

  protected processCourseStudentGroupSessionsGet(
    response: Response,
  ): Promise<CourseSessionListItem[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) result200!.push(CourseSessionListItem.fromJS(item))
        } else {
          result200 = null as any
        }
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSessionListItem[]>(null as any)
  }

  /**
   * @param courseGroupId (optional)
   * @return Success
   */
  courseStudentAttendanceGet(courseGroupId: number | undefined): Promise<AttendanceLog[]> {
    let url_ = this.baseUrl + '/course/student/attendance/get?'
    if (courseGroupId === null)
      throw new globalThis.Error("The parameter 'courseGroupId' cannot be null.")
    else if (courseGroupId !== undefined)
      url_ += 'courseGroupId=' + encodeURIComponent('' + courseGroupId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseStudentAttendanceGet(_response)
    })
  }

  protected processCourseStudentAttendanceGet(response: Response): Promise<AttendanceLog[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) result200!.push(AttendanceLog.fromJS(item))
        } else {
          result200 = null as any
        }
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<AttendanceLog[]>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  courseSessionSave(body: CourseSession | undefined): Promise<CourseSession> {
    let url_ = this.baseUrl + '/course/session/save'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSessionSave(_response)
    })
  }

  protected processCourseSessionSave(response: Response): Promise<CourseSession> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = CourseSession.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSession>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  courseStudentSessionsGet(
    body: CourseSessionListFiltersPagedListParams | undefined,
  ): Promise<CourseSessionListItemPagedList> {
    let url_ = this.baseUrl + '/course/student/sessions/get'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseStudentSessionsGet(_response)
    })
  }

  protected processCourseStudentSessionsGet(
    response: Response,
  ): Promise<CourseSessionListItemPagedList> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = CourseSessionListItemPagedList.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSessionListItemPagedList>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  courseTeacherSessionsGet(
    body: CourseSessionListFiltersPagedListParams | undefined,
  ): Promise<CourseSessionListItemPagedList> {
    let url_ = this.baseUrl + '/course/teacher/sessions/get'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseTeacherSessionsGet(_response)
    })
  }

  protected processCourseTeacherSessionsGet(
    response: Response,
  ): Promise<CourseSessionListItemPagedList> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = CourseSessionListItemPagedList.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSessionListItemPagedList>(null as any)
  }

  /**
   * @param sessionId (optional)
   * @return Success
   */
  courseSessionAttendanceListGet(
    sessionId: number | undefined,
  ): Promise<CourseSessionAttendanceRecord[]> {
    let url_ = this.baseUrl + '/course/session/attendance-list/get?'
    if (sessionId === null) throw new globalThis.Error("The parameter 'sessionId' cannot be null.")
    else if (sessionId !== undefined)
      url_ += 'sessionId=' + encodeURIComponent('' + sessionId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSessionAttendanceListGet(_response)
    })
  }

  protected processCourseSessionAttendanceListGet(
    response: Response,
  ): Promise<CourseSessionAttendanceRecord[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200)
            result200!.push(CourseSessionAttendanceRecord.fromJS(item))
        } else {
          result200 = null as any
        }
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<CourseSessionAttendanceRecord[]>(null as any)
  }

  /**
   * @param courseSessionId (optional)
   * @return Success
   */
  courseSessionAttendanceScannerTokenGet(
    courseSessionId: number | undefined,
  ): Promise<TokenResult> {
    let url_ = this.baseUrl + '/course/session/attendance/scanner/token/get?'
    if (courseSessionId === null)
      throw new globalThis.Error("The parameter 'courseSessionId' cannot be null.")
    else if (courseSessionId !== undefined)
      url_ += 'courseSessionId=' + encodeURIComponent('' + courseSessionId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSessionAttendanceScannerTokenGet(_response)
    })
  }

  protected processCourseSessionAttendanceScannerTokenGet(
    response: Response,
  ): Promise<TokenResult> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = TokenResult.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<TokenResult>(null as any)
  }

  /**
   * @param attenderToken (optional)
   * @return Success
   */
  courseSessionAttendanceRegister(attenderToken: string | undefined): Promise<User> {
    let url_ = this.baseUrl + '/course/session/attendance/register?'
    if (attenderToken === null)
      throw new globalThis.Error("The parameter 'attenderToken' cannot be null.")
    else if (attenderToken !== undefined)
      url_ += 'attenderToken=' + encodeURIComponent('' + attenderToken) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSessionAttendanceRegister(_response)
    })
  }

  protected processCourseSessionAttendanceRegister(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        let resultData400 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result400 = ProblemDetails.fromJS(resultData400)
        return throwException('Bad Request', status, _responseText, _headers, result400)
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<User>(null as any)
  }

  /**
   * @param attendingUserId (optional)
   * @param courseSessionId (optional)
   * @param addOrRemove (optional)
   * @return Success
   */
  courseSessionAttendanceToggle(
    attendingUserId: number | undefined,
    courseSessionId: number | undefined,
    addOrRemove: boolean | undefined,
  ): Promise<AttendanceLog[]> {
    let url_ = this.baseUrl + '/course/session/attendance/toggle?'
    if (attendingUserId === null)
      throw new globalThis.Error("The parameter 'attendingUserId' cannot be null.")
    else if (attendingUserId !== undefined)
      url_ += 'attendingUserId=' + encodeURIComponent('' + attendingUserId) + '&'
    if (courseSessionId === null)
      throw new globalThis.Error("The parameter 'courseSessionId' cannot be null.")
    else if (courseSessionId !== undefined)
      url_ += 'courseSessionId=' + encodeURIComponent('' + courseSessionId) + '&'
    if (addOrRemove === null)
      throw new globalThis.Error("The parameter 'addOrRemove' cannot be null.")
    else if (addOrRemove !== undefined)
      url_ += 'addOrRemove=' + encodeURIComponent('' + addOrRemove) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCourseSessionAttendanceToggle(_response)
    })
  }

  protected processCourseSessionAttendanceToggle(response: Response): Promise<AttendanceLog[]> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        if (Array.isArray(resultData200)) {
          result200 = [] as any
          for (let item of resultData200) result200!.push(AttendanceLog.fromJS(item))
        } else {
          result200 = null as any
        }
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        let resultData400 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result400 = ProblemDetails.fromJS(resultData400)
        return throwException('Bad Request', status, _responseText, _headers, result400)
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<AttendanceLog[]>(null as any)
  }

  /**
   * @param token (optional)
   * @return Success
   */
  testTokenDecode(token: string | undefined): Promise<string> {
    let url_ = this.baseUrl + '/test/token-decode?'
    if (token === null) throw new globalThis.Error("The parameter 'token' cannot be null.")
    else if (token !== undefined) url_ += 'token=' + encodeURIComponent('' + token) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTestTokenDecode(_response)
    })
  }

  protected processTestTokenDecode(response: Response): Promise<string> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : (null as any)

        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<string>(null as any)
  }

  /**
   * @param loginName (optional)
   * @param password (optional)
   * @return Success
   */
  userLogin(loginName: string | undefined, password: string | undefined): Promise<TokenResult> {
    let url_ = this.baseUrl + '/user/login?'
    if (loginName === null) throw new globalThis.Error("The parameter 'loginName' cannot be null.")
    else if (loginName !== undefined)
      url_ += 'loginName=' + encodeURIComponent('' + loginName) + '&'
    if (password === null) throw new globalThis.Error("The parameter 'password' cannot be null.")
    else if (password !== undefined) url_ += 'password=' + encodeURIComponent('' + password) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserLogin(_response)
    })
  }

  protected processUserLogin(response: Response): Promise<TokenResult> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = TokenResult.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<TokenResult>(null as any)
  }

  /**
   * @param deviceUserId (optional)
   * @return Success
   */
  userDeviceReset(deviceUserId: number | undefined): Promise<void> {
    let url_ = this.baseUrl + '/user/device/reset?'
    if (deviceUserId === null)
      throw new globalThis.Error("The parameter 'deviceUserId' cannot be null.")
    else if (deviceUserId !== undefined)
      url_ += 'deviceUserId=' + encodeURIComponent('' + deviceUserId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserDeviceReset(_response)
    })
  }

  protected processUserDeviceReset(response: Response): Promise<void> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<void>(null as any)
  }

  /**
   * @param deviceUserId (optional)
   * @return Success
   */
  userDeviceRegisterTokenGet(deviceUserId: number | undefined): Promise<TokenResult> {
    let url_ = this.baseUrl + '/user/device/register/token/get?'
    if (deviceUserId === null)
      throw new globalThis.Error("The parameter 'deviceUserId' cannot be null.")
    else if (deviceUserId !== undefined)
      url_ += 'deviceUserId=' + encodeURIComponent('' + deviceUserId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserDeviceRegisterTokenGet(_response)
    })
  }

  protected processUserDeviceRegisterTokenGet(response: Response): Promise<TokenResult> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = TokenResult.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<TokenResult>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  userDeviceRegister(body: DeviceRegisterDTO | undefined): Promise<TokenResult> {
    let url_ = this.baseUrl + '/user/device/register'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserDeviceRegister(_response)
    })
  }

  protected processUserDeviceRegister(response: Response): Promise<TokenResult> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = TokenResult.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<TokenResult>(null as any)
  }

  /**
   * @return Success
   */
  userAttendanceTicketGet(): Promise<TokenResult> {
    let url_ = this.baseUrl + '/user/attendance/ticket/get'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserAttendanceTicketGet(_response)
    })
  }

  protected processUserAttendanceTicketGet(response: Response): Promise<TokenResult> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = TokenResult.fromJS(resultData200)
        return result200
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<TokenResult>(null as any)
  }

  /**
   * @param userId (optional)
   * @return Success
   */
  userGet(userId: number | undefined): Promise<User> {
    let url_ = this.baseUrl + '/user/get?'
    if (userId === null) throw new globalThis.Error("The parameter 'userId' cannot be null.")
    else if (userId !== undefined) url_ += 'userId=' + encodeURIComponent('' + userId) + '&'
    url_ = url_.replace(/[?&]$/, '')

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserGet(_response)
    })
  }

  protected processUserGet(response: Response): Promise<User> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = User.fromJS(resultData200)
        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<User>(null as any)
  }

  /**
   * @param loginName (optional)
   * @param password (optional)
   * @param body (optional)
   * @return Success
   */
  userStudentCreate(
    loginName: string | undefined,
    password: string | undefined,
    body: StudentUserDTO | undefined,
  ): Promise<number> {
    let url_ = this.baseUrl + '/user/student/create?'
    if (loginName === null) throw new globalThis.Error("The parameter 'loginName' cannot be null.")
    else if (loginName !== undefined)
      url_ += 'loginName=' + encodeURIComponent('' + loginName) + '&'
    if (password === null) throw new globalThis.Error("The parameter 'password' cannot be null.")
    else if (password !== undefined) url_ += 'password=' + encodeURIComponent('' + password) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserStudentCreate(_response)
    })
  }

  protected processUserStudentCreate(response: Response): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : (null as any)

        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<number>(null as any)
  }

  /**
   * @param loginName (optional)
   * @param password (optional)
   * @param body (optional)
   * @return Success
   */
  userTeacherCreate(
    loginName: string | undefined,
    password: string | undefined,
    body: TeacherUserDTO | undefined,
  ): Promise<number> {
    let url_ = this.baseUrl + '/user/teacher/create?'
    if (loginName === null) throw new globalThis.Error("The parameter 'loginName' cannot be null.")
    else if (loginName !== undefined)
      url_ += 'loginName=' + encodeURIComponent('' + loginName) + '&'
    if (password === null) throw new globalThis.Error("The parameter 'password' cannot be null.")
    else if (password !== undefined) url_ += 'password=' + encodeURIComponent('' + password) + '&'
    url_ = url_.replace(/[?&]$/, '')

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserTeacherCreate(_response)
    })
  }

  protected processUserTeacherCreate(response: Response): Promise<number> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        let resultData200 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result200 = resultData200 !== undefined ? resultData200 : (null as any)

        return result200
      })
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null
        let resultData403 =
          _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver)
        result403 = ProblemDetails.fromJS(resultData403)
        return throwException('Forbidden', status, _responseText, _headers, result403)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        )
      })
    }
    return Promise.resolve<number>(null as any)
  }
}

export class AttendanceLog implements IAttendanceLog {
  attendanceLogId?: number
  attenderUserId?: number
  courseSessionId?: number
  readonly dateCreated?: Date

  constructor(data?: IAttendanceLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attendanceLogId = _data['attendanceLogId']
      this.attenderUserId = _data['attenderUserId']
      this.courseSessionId = _data['courseSessionId']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): AttendanceLog {
    data = typeof data === 'object' ? data : {}
    let result = new AttendanceLog()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['attendanceLogId'] = this.attendanceLogId
    data['attenderUserId'] = this.attenderUserId
    data['courseSessionId'] = this.courseSessionId
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    return data
  }
}

export interface IAttendanceLog {
  attendanceLogId?: number
  attenderUserId?: number
  courseSessionId?: number
  dateCreated?: Date
}

export class AttenderGroup implements IAttenderGroup {
  attenderGroupId?: number
  groupName?: string
  yearOfStudy?: number
  studyDirection?: string
  readonly dateCreated?: Date
  attenderGroupMembers?: AttenderGroupMember[] | undefined

  constructor(data?: IAttenderGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attenderGroupId = _data['attenderGroupId']
      this.groupName = _data['groupName']
      this.yearOfStudy = _data['yearOfStudy']
      this.studyDirection = _data['studyDirection']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      if (Array.isArray(_data['attenderGroupMembers'])) {
        this.attenderGroupMembers = [] as any
        for (let item of _data['attenderGroupMembers'])
          this.attenderGroupMembers!.push(AttenderGroupMember.fromJS(item))
      }
    }
  }

  static fromJS(data: any): AttenderGroup {
    data = typeof data === 'object' ? data : {}
    let result = new AttenderGroup()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['attenderGroupId'] = this.attenderGroupId
    data['groupName'] = this.groupName
    data['yearOfStudy'] = this.yearOfStudy
    data['studyDirection'] = this.studyDirection
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    if (Array.isArray(this.attenderGroupMembers)) {
      data['attenderGroupMembers'] = []
      for (let item of this.attenderGroupMembers)
        data['attenderGroupMembers'].push(item ? item.toJSON() : (undefined as any))
    }
    return data
  }
}

export interface IAttenderGroup {
  attenderGroupId?: number
  groupName?: string
  yearOfStudy?: number
  studyDirection?: string
  dateCreated?: Date
  attenderGroupMembers?: AttenderGroupMember[] | undefined
}

export class AttenderGroupMember implements IAttenderGroupMember {
  attenderGroupMemberId?: number
  memberUserId?: number
  memberUser?: User
  attenderGroupId?: number
  attenderGroup?: AttenderGroup
  readonly dateCreated?: Date

  constructor(data?: IAttenderGroupMember) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attenderGroupMemberId = _data['attenderGroupMemberId']
      this.memberUserId = _data['memberUserId']
      this.memberUser = _data['memberUser'] ? User.fromJS(_data['memberUser']) : (undefined as any)
      this.attenderGroupId = _data['attenderGroupId']
      this.attenderGroup = _data['attenderGroup']
        ? AttenderGroup.fromJS(_data['attenderGroup'])
        : (undefined as any)
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): AttenderGroupMember {
    data = typeof data === 'object' ? data : {}
    let result = new AttenderGroupMember()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['attenderGroupMemberId'] = this.attenderGroupMemberId
    data['memberUserId'] = this.memberUserId
    data['memberUser'] = this.memberUser ? this.memberUser.toJSON() : (undefined as any)
    data['attenderGroupId'] = this.attenderGroupId
    data['attenderGroup'] = this.attenderGroup ? this.attenderGroup.toJSON() : (undefined as any)
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    return data
  }
}

export interface IAttenderGroupMember {
  attenderGroupMemberId?: number
  memberUserId?: number
  memberUser?: User
  attenderGroupId?: number
  attenderGroup?: AttenderGroup
  dateCreated?: Date
}

export class Course implements ICourse {
  courseId?: number
  courseName?: string
  courseDescription?: string
  readonly dateCreated?: Date
  courseGroups?: CourseGroup[] | undefined

  constructor(data?: ICourse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.courseId = _data['courseId']
      this.courseName = _data['courseName']
      this.courseDescription = _data['courseDescription']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      if (Array.isArray(_data['courseGroups'])) {
        this.courseGroups = [] as any
        for (let item of _data['courseGroups']) this.courseGroups!.push(CourseGroup.fromJS(item))
      }
    }
  }

  static fromJS(data: any): Course {
    data = typeof data === 'object' ? data : {}
    let result = new Course()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseId'] = this.courseId
    data['courseName'] = this.courseName
    data['courseDescription'] = this.courseDescription
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    if (Array.isArray(this.courseGroups)) {
      data['courseGroups'] = []
      for (let item of this.courseGroups)
        data['courseGroups'].push(item ? item.toJSON() : (undefined as any))
    }
    return data
  }
}

export interface ICourse {
  courseId?: number
  courseName?: string
  courseDescription?: string
  dateCreated?: Date
  courseGroups?: CourseGroup[] | undefined
}

export class CourseGroup implements ICourseGroup {
  courseGroupId?: number
  courseId?: number
  course?: Course
  courseGroupType?: string
  courseGroupName?: string
  courseGroupDescription?: string | undefined
  teacherUserId?: number | undefined
  teacherUser?: User
  sessions?: CourseSession[] | undefined
  attenderGroupAssigments?: CourseGroupAttenderGroupAssigment[] | undefined
  userAssigments?: CourseGroupUserAssigment[] | undefined
  yearOfStudy?: number
  semesterCode?: string | undefined
  dateStart?: Date
  dateEnd?: Date
  readonly dateCreated?: Date

  constructor(data?: ICourseGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.courseGroupId = _data['courseGroupId']
      this.courseId = _data['courseId']
      this.course = _data['course'] ? Course.fromJS(_data['course']) : (undefined as any)
      this.courseGroupType = _data['courseGroupType']
      this.courseGroupName = _data['courseGroupName']
      this.courseGroupDescription = _data['courseGroupDescription']
      this.teacherUserId = _data['teacherUserId']
      this.teacherUser = _data['teacherUser']
        ? User.fromJS(_data['teacherUser'])
        : (undefined as any)
      if (Array.isArray(_data['sessions'])) {
        this.sessions = [] as any
        for (let item of _data['sessions']) this.sessions!.push(CourseSession.fromJS(item))
      }
      if (Array.isArray(_data['attenderGroupAssigments'])) {
        this.attenderGroupAssigments = [] as any
        for (let item of _data['attenderGroupAssigments'])
          this.attenderGroupAssigments!.push(CourseGroupAttenderGroupAssigment.fromJS(item))
      }
      if (Array.isArray(_data['userAssigments'])) {
        this.userAssigments = [] as any
        for (let item of _data['userAssigments'])
          this.userAssigments!.push(CourseGroupUserAssigment.fromJS(item))
      }
      this.yearOfStudy = _data['yearOfStudy']
      this.semesterCode = _data['semesterCode']
      this.dateStart = _data['dateStart']
        ? new Date(_data['dateStart'].toString())
        : (undefined as any)
      this.dateEnd = _data['dateEnd'] ? new Date(_data['dateEnd'].toString()) : (undefined as any)
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): CourseGroup {
    data = typeof data === 'object' ? data : {}
    let result = new CourseGroup()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseGroupId'] = this.courseGroupId
    data['courseId'] = this.courseId
    data['course'] = this.course ? this.course.toJSON() : (undefined as any)
    data['courseGroupType'] = this.courseGroupType
    data['courseGroupName'] = this.courseGroupName
    data['courseGroupDescription'] = this.courseGroupDescription
    data['teacherUserId'] = this.teacherUserId
    data['teacherUser'] = this.teacherUser ? this.teacherUser.toJSON() : (undefined as any)
    if (Array.isArray(this.sessions)) {
      data['sessions'] = []
      for (let item of this.sessions)
        data['sessions'].push(item ? item.toJSON() : (undefined as any))
    }
    if (Array.isArray(this.attenderGroupAssigments)) {
      data['attenderGroupAssigments'] = []
      for (let item of this.attenderGroupAssigments)
        data['attenderGroupAssigments'].push(item ? item.toJSON() : (undefined as any))
    }
    if (Array.isArray(this.userAssigments)) {
      data['userAssigments'] = []
      for (let item of this.userAssigments)
        data['userAssigments'].push(item ? item.toJSON() : (undefined as any))
    }
    data['yearOfStudy'] = this.yearOfStudy
    data['semesterCode'] = this.semesterCode
    data['dateStart'] = this.dateStart ? this.dateStart.toISOString() : (undefined as any)
    data['dateEnd'] = this.dateEnd ? this.dateEnd.toISOString() : (undefined as any)
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    return data
  }
}

export interface ICourseGroup {
  courseGroupId?: number
  courseId?: number
  course?: Course
  courseGroupType?: string
  courseGroupName?: string
  courseGroupDescription?: string | undefined
  teacherUserId?: number | undefined
  teacherUser?: User
  sessions?: CourseSession[] | undefined
  attenderGroupAssigments?: CourseGroupAttenderGroupAssigment[] | undefined
  userAssigments?: CourseGroupUserAssigment[] | undefined
  yearOfStudy?: number
  semesterCode?: string | undefined
  dateStart?: Date
  dateEnd?: Date
  dateCreated?: Date
}

export class CourseGroupAttenderGroupAssigment implements ICourseGroupAttenderGroupAssigment {
  courseGroupAttenderGroupAssigmentId?: number
  courseGroupId?: number
  attenderGroupId?: number | undefined
  isExcluded?: boolean
  readonly dateCreated?: Date
  courseGroup?: CourseGroup
  attenderGroup?: AttenderGroup

  constructor(data?: ICourseGroupAttenderGroupAssigment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.courseGroupAttenderGroupAssigmentId = _data['courseGroupAttenderGroupAssigmentId']
      this.courseGroupId = _data['courseGroupId']
      this.attenderGroupId = _data['attenderGroupId']
      this.isExcluded = _data['isExcluded']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      this.courseGroup = _data['courseGroup']
        ? CourseGroup.fromJS(_data['courseGroup'])
        : (undefined as any)
      this.attenderGroup = _data['attenderGroup']
        ? AttenderGroup.fromJS(_data['attenderGroup'])
        : (undefined as any)
    }
  }

  static fromJS(data: any): CourseGroupAttenderGroupAssigment {
    data = typeof data === 'object' ? data : {}
    let result = new CourseGroupAttenderGroupAssigment()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseGroupAttenderGroupAssigmentId'] = this.courseGroupAttenderGroupAssigmentId
    data['courseGroupId'] = this.courseGroupId
    data['attenderGroupId'] = this.attenderGroupId
    data['isExcluded'] = this.isExcluded
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    data['courseGroup'] = this.courseGroup ? this.courseGroup.toJSON() : (undefined as any)
    data['attenderGroup'] = this.attenderGroup ? this.attenderGroup.toJSON() : (undefined as any)
    return data
  }
}

export interface ICourseGroupAttenderGroupAssigment {
  courseGroupAttenderGroupAssigmentId?: number
  courseGroupId?: number
  attenderGroupId?: number | undefined
  isExcluded?: boolean
  dateCreated?: Date
  courseGroup?: CourseGroup
  attenderGroup?: AttenderGroup
}

export class CourseGroupUserAssigment implements ICourseGroupUserAssigment {
  courseGroupUserAssigmentId?: number
  courseGroupId?: number
  courseGroup?: CourseGroup
  userId?: number | undefined
  readonly dateCreated?: Date
  isExcluded?: boolean
  user?: User

  constructor(data?: ICourseGroupUserAssigment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.courseGroupUserAssigmentId = _data['courseGroupUserAssigmentId']
      this.courseGroupId = _data['courseGroupId']
      this.courseGroup = _data['courseGroup']
        ? CourseGroup.fromJS(_data['courseGroup'])
        : (undefined as any)
      this.userId = _data['userId']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      this.isExcluded = _data['isExcluded']
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any)
    }
  }

  static fromJS(data: any): CourseGroupUserAssigment {
    data = typeof data === 'object' ? data : {}
    let result = new CourseGroupUserAssigment()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseGroupUserAssigmentId'] = this.courseGroupUserAssigmentId
    data['courseGroupId'] = this.courseGroupId
    data['courseGroup'] = this.courseGroup ? this.courseGroup.toJSON() : (undefined as any)
    data['userId'] = this.userId
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    data['isExcluded'] = this.isExcluded
    data['user'] = this.user ? this.user.toJSON() : (undefined as any)
    return data
  }
}

export interface ICourseGroupUserAssigment {
  courseGroupUserAssigmentId?: number
  courseGroupId?: number
  courseGroup?: CourseGroup
  userId?: number | undefined
  dateCreated?: Date
  isExcluded?: boolean
  user?: User
}

export class CourseSession implements ICourseSession {
  courseSessionId?: number
  courseGroupId?: number
  courseGroup?: CourseGroup
  locationName?: string
  dateStart?: Date
  dateEnd?: Date
  readonly dateCreated?: Date
  attendanceLogs?: AttendanceLog[]

  constructor(data?: ICourseSession) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.courseSessionId = _data['courseSessionId']
      this.courseGroupId = _data['courseGroupId']
      this.courseGroup = _data['courseGroup']
        ? CourseGroup.fromJS(_data['courseGroup'])
        : (undefined as any)
      this.locationName = _data['locationName']
      this.dateStart = _data['dateStart']
        ? new Date(_data['dateStart'].toString())
        : (undefined as any)
      this.dateEnd = _data['dateEnd'] ? new Date(_data['dateEnd'].toString()) : (undefined as any)
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      if (Array.isArray(_data['attendanceLogs'])) {
        this.attendanceLogs = [] as any
        for (let item of _data['attendanceLogs'])
          this.attendanceLogs!.push(AttendanceLog.fromJS(item))
      }
    }
  }

  static fromJS(data: any): CourseSession {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSession()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseSessionId'] = this.courseSessionId
    data['courseGroupId'] = this.courseGroupId
    data['courseGroup'] = this.courseGroup ? this.courseGroup.toJSON() : (undefined as any)
    data['locationName'] = this.locationName
    data['dateStart'] = this.dateStart ? this.dateStart.toISOString() : (undefined as any)
    data['dateEnd'] = this.dateEnd ? this.dateEnd.toISOString() : (undefined as any)
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    if (Array.isArray(this.attendanceLogs)) {
      data['attendanceLogs'] = []
      for (let item of this.attendanceLogs)
        data['attendanceLogs'].push(item ? item.toJSON() : (undefined as any))
    }
    return data
  }
}

export interface ICourseSession {
  courseSessionId?: number
  courseGroupId?: number
  courseGroup?: CourseGroup
  locationName?: string
  dateStart?: Date
  dateEnd?: Date
  dateCreated?: Date
  attendanceLogs?: AttendanceLog[]
}

export class CourseSessionAttendanceRecord implements ICourseSessionAttendanceRecord {
  attendanceLogId?: number | undefined
  courseSessionId?: number
  attenderUserId?: number | undefined
  userName?: string | undefined
  userSurname?: string | undefined
  studentAlbumIdNumber?: number | undefined
  attendanceLogMinDateCreated?: Date | undefined
  readonly wasUserPresent?: boolean

  constructor(data?: ICourseSessionAttendanceRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attendanceLogId = _data['attendanceLogId']
      this.courseSessionId = _data['courseSessionId']
      this.attenderUserId = _data['attenderUserId']
      this.userName = _data['userName']
      this.userSurname = _data['userSurname']
      this.studentAlbumIdNumber = _data['studentAlbumIdNumber']
      this.attendanceLogMinDateCreated = _data['attendanceLogMinDateCreated']
        ? new Date(_data['attendanceLogMinDateCreated'].toString())
        : (undefined as any)
      ;(this as any).wasUserPresent = _data['wasUserPresent']
    }
  }

  static fromJS(data: any): CourseSessionAttendanceRecord {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSessionAttendanceRecord()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['attendanceLogId'] = this.attendanceLogId
    data['courseSessionId'] = this.courseSessionId
    data['attenderUserId'] = this.attenderUserId
    data['userName'] = this.userName
    data['userSurname'] = this.userSurname
    data['studentAlbumIdNumber'] = this.studentAlbumIdNumber
    data['attendanceLogMinDateCreated'] = this.attendanceLogMinDateCreated
      ? this.attendanceLogMinDateCreated.toISOString()
      : (undefined as any)
    data['wasUserPresent'] = this.wasUserPresent
    return data
  }
}

export interface ICourseSessionAttendanceRecord {
  attendanceLogId?: number | undefined
  courseSessionId?: number
  attenderUserId?: number | undefined
  userName?: string | undefined
  userSurname?: string | undefined
  studentAlbumIdNumber?: number | undefined
  attendanceLogMinDateCreated?: Date | undefined
  wasUserPresent?: boolean
}

export class CourseSessionListFilters implements ICourseSessionListFilters {
  search?: string | undefined
  courseName?: string | undefined
  courseGroupName?: string | undefined
  locationName?: string | undefined
  dateStart?: Date | undefined
  dateEnd?: Date | undefined

  constructor(data?: ICourseSessionListFilters) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.search = _data['search']
      this.courseName = _data['courseName']
      this.courseGroupName = _data['courseGroupName']
      this.locationName = _data['locationName']
      this.dateStart = _data['dateStart']
        ? new Date(_data['dateStart'].toString())
        : (undefined as any)
      this.dateEnd = _data['dateEnd'] ? new Date(_data['dateEnd'].toString()) : (undefined as any)
    }
  }

  static fromJS(data: any): CourseSessionListFilters {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSessionListFilters()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['search'] = this.search
    data['courseName'] = this.courseName
    data['courseGroupName'] = this.courseGroupName
    data['locationName'] = this.locationName
    data['dateStart'] = this.dateStart ? this.dateStart.toISOString() : (undefined as any)
    data['dateEnd'] = this.dateEnd ? this.dateEnd.toISOString() : (undefined as any)
    return data
  }
}

export interface ICourseSessionListFilters {
  search?: string | undefined
  courseName?: string | undefined
  courseGroupName?: string | undefined
  locationName?: string | undefined
  dateStart?: Date | undefined
  dateEnd?: Date | undefined
}

export class CourseSessionListFiltersPagedListParams
  implements ICourseSessionListFiltersPagedListParams
{
  pageNumber!: number
  pageSize!: number
  filters?: CourseSessionListFilters
  sortBy?: string | undefined

  constructor(data?: ICourseSessionListFiltersPagedListParams) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data['pageNumber']
      this.pageSize = _data['pageSize']
      this.filters = _data['filters']
        ? CourseSessionListFilters.fromJS(_data['filters'])
        : (undefined as any)
      this.sortBy = _data['sortBy']
    }
  }

  static fromJS(data: any): CourseSessionListFiltersPagedListParams {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSessionListFiltersPagedListParams()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['pageNumber'] = this.pageNumber
    data['pageSize'] = this.pageSize
    data['filters'] = this.filters ? this.filters.toJSON() : (undefined as any)
    data['sortBy'] = this.sortBy
    return data
  }
}

export interface ICourseSessionListFiltersPagedListParams {
  pageNumber: number
  pageSize: number
  filters?: CourseSessionListFilters
  sortBy?: string | undefined
}

export class CourseSessionListItem implements ICourseSessionListItem {
  readonly courseId?: number
  readonly courseName?: string
  readonly courseGroupId?: number
  readonly courseGroupName?: string
  readonly courseSessionId?: number
  readonly locationName?: string
  readonly dateStart?: Date
  readonly dateEnd?: Date

  constructor(data?: ICourseSessionListItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      ;(this as any).courseId = _data['courseId']
      ;(this as any).courseName = _data['courseName']
      ;(this as any).courseGroupId = _data['courseGroupId']
      ;(this as any).courseGroupName = _data['courseGroupName']
      ;(this as any).courseSessionId = _data['courseSessionId']
      ;(this as any).locationName = _data['locationName']
      ;(this as any).dateStart = _data['dateStart']
        ? new Date(_data['dateStart'].toString())
        : (undefined as any)
      ;(this as any).dateEnd = _data['dateEnd']
        ? new Date(_data['dateEnd'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): CourseSessionListItem {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSessionListItem()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['courseId'] = this.courseId
    data['courseName'] = this.courseName
    data['courseGroupId'] = this.courseGroupId
    data['courseGroupName'] = this.courseGroupName
    data['courseSessionId'] = this.courseSessionId
    data['locationName'] = this.locationName
    data['dateStart'] = this.dateStart ? this.dateStart.toISOString() : (undefined as any)
    data['dateEnd'] = this.dateEnd ? this.dateEnd.toISOString() : (undefined as any)
    return data
  }
}

export interface ICourseSessionListItem {
  courseId?: number
  courseName?: string
  courseGroupId?: number
  courseGroupName?: string
  courseSessionId?: number
  locationName?: string
  dateStart?: Date
  dateEnd?: Date
}

export class CourseSessionListItemPagedList implements ICourseSessionListItemPagedList {
  items!: CourseSessionListItem[]
  totalCount!: number
  pageNumber!: number
  pageSize!: number
  readonly totalPages!: number

  constructor(data?: ICourseSessionListItemPagedList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
    if (!data) {
      this.items = []
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any
        for (let item of _data['items']) this.items!.push(CourseSessionListItem.fromJS(item))
      }
      this.totalCount = _data['totalCount']
      this.pageNumber = _data['pageNumber']
      this.pageSize = _data['pageSize']
      ;(this as any).totalPages = _data['totalPages']
    }
  }

  static fromJS(data: any): CourseSessionListItemPagedList {
    data = typeof data === 'object' ? data : {}
    let result = new CourseSessionListItemPagedList()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    if (Array.isArray(this.items)) {
      data['items'] = []
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any))
    }
    data['totalCount'] = this.totalCount
    data['pageNumber'] = this.pageNumber
    data['pageSize'] = this.pageSize
    data['totalPages'] = this.totalPages
    return data
  }
}

export interface ICourseSessionListItemPagedList {
  items: CourseSessionListItem[]
  totalCount: number
  pageNumber: number
  pageSize: number
  totalPages: number
}

export class DeviceRegisterDTO implements IDeviceRegisterDTO {
  deviceName?: string
  studentName?: string
  studentSurname?: string
  albumIdNumber?: number

  constructor(data?: IDeviceRegisterDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceName = _data['deviceName']
      this.studentName = _data['studentName']
      this.studentSurname = _data['studentSurname']
      this.albumIdNumber = _data['albumIdNumber']
    }
  }

  static fromJS(data: any): DeviceRegisterDTO {
    data = typeof data === 'object' ? data : {}
    let result = new DeviceRegisterDTO()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['deviceName'] = this.deviceName
    data['studentName'] = this.studentName
    data['studentSurname'] = this.studentSurname
    data['albumIdNumber'] = this.albumIdNumber
    return data
  }
}

export interface IDeviceRegisterDTO {
  deviceName?: string
  studentName?: string
  studentSurname?: string
  albumIdNumber?: number
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined
  title?: string | undefined
  status?: number | undefined
  detail?: string | undefined
  instance?: string | undefined;

  [key: string]: any

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property]
      }
      this.type = _data['type']
      this.title = _data['title']
      this.status = _data['status']
      this.detail = _data['detail']
      this.instance = _data['instance']
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {}
    let result = new ProblemDetails()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property]
    }
    data['type'] = this.type
    data['title'] = this.title
    data['status'] = this.status
    data['detail'] = this.detail
    data['instance'] = this.instance
    return data
  }
}

export interface IProblemDetails {
  type?: string | undefined
  title?: string | undefined
  status?: number | undefined
  detail?: string | undefined
  instance?: string | undefined

  [key: string]: any
}

export class Student implements IStudent {
  studentId?: number
  albumIdNumber?: number
  currentYearOfStudy?: number
  readonly dateCreated?: Date

  constructor(data?: IStudent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.studentId = _data['studentId']
      this.albumIdNumber = _data['albumIdNumber']
      this.currentYearOfStudy = _data['currentYearOfStudy']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): Student {
    data = typeof data === 'object' ? data : {}
    let result = new Student()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['studentId'] = this.studentId
    data['albumIdNumber'] = this.albumIdNumber
    data['currentYearOfStudy'] = this.currentYearOfStudy
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    return data
  }
}

export interface IStudent {
  studentId?: number
  albumIdNumber?: number
  currentYearOfStudy?: number
  dateCreated?: Date
}

export class StudentUserDTO implements IStudentUserDTO {
  readonly userId?: number
  name?: string
  surname?: string
  albumIdNumber?: number

  constructor(data?: IStudentUserDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      ;(this as any).userId = _data['userId']
      this.name = _data['name']
      this.surname = _data['surname']
      this.albumIdNumber = _data['albumIdNumber']
    }
  }

  static fromJS(data: any): StudentUserDTO {
    data = typeof data === 'object' ? data : {}
    let result = new StudentUserDTO()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['name'] = this.name
    data['surname'] = this.surname
    data['albumIdNumber'] = this.albumIdNumber
    return data
  }
}

export interface IStudentUserDTO {
  userId?: number
  name?: string
  surname?: string
  albumIdNumber?: number
}

export class Teacher implements ITeacher {
  teacherId?: number
  academicTitle?: string
  readonly dateCreated?: Date

  constructor(data?: ITeacher) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.teacherId = _data['teacherId']
      this.academicTitle = _data['academicTitle']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
    }
  }

  static fromJS(data: any): Teacher {
    data = typeof data === 'object' ? data : {}
    let result = new Teacher()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['teacherId'] = this.teacherId
    data['academicTitle'] = this.academicTitle
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    return data
  }
}

export interface ITeacher {
  teacherId?: number
  academicTitle?: string
  dateCreated?: Date
}

export class TeacherUserDTO implements ITeacherUserDTO {
  readonly userId?: number
  name?: string
  surname?: string
  academicTitle?: string

  constructor(data?: ITeacherUserDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      ;(this as any).userId = _data['userId']
      this.name = _data['name']
      this.surname = _data['surname']
      this.academicTitle = _data['academicTitle']
    }
  }

  static fromJS(data: any): TeacherUserDTO {
    data = typeof data === 'object' ? data : {}
    let result = new TeacherUserDTO()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['name'] = this.name
    data['surname'] = this.surname
    data['academicTitle'] = this.academicTitle
    return data
  }
}

export interface ITeacherUserDTO {
  userId?: number
  name?: string
  surname?: string
  academicTitle?: string
}

export class TokenResult implements ITokenResult {
  token?: string
  expires?: Date | undefined

  constructor(data?: ITokenResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data['token']
      this.expires = _data['expires'] ? new Date(_data['expires'].toString()) : (undefined as any)
    }
  }

  static fromJS(data: any): TokenResult {
    data = typeof data === 'object' ? data : {}
    let result = new TokenResult()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['token'] = this.token
    data['expires'] = this.expires ? this.expires.toISOString() : (undefined as any)
    return data
  }
}

export interface ITokenResult {
  token?: string
  expires?: Date | undefined
}

export class User implements IUser {
  userId?: number
  loginName?: string
  name?: string | undefined
  surname?: string | undefined
  studentId?: number | undefined
  teacherId?: number | undefined
  student?: Student
  readonly isStudent?: boolean
  teacher?: Teacher
  readonly isTeacher?: boolean
  readonly dateCreated?: Date
  deviceName?: string | undefined
  isAdmin?: boolean

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property]
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId']
      this.loginName = _data['loginName']
      this.name = _data['name']
      this.surname = _data['surname']
      this.studentId = _data['studentId']
      this.teacherId = _data['teacherId']
      this.student = _data['student'] ? Student.fromJS(_data['student']) : (undefined as any)
      ;(this as any).isStudent = _data['isStudent']
      this.teacher = _data['teacher'] ? Teacher.fromJS(_data['teacher']) : (undefined as any)
      ;(this as any).isTeacher = _data['isTeacher']
      ;(this as any).dateCreated = _data['dateCreated']
        ? new Date(_data['dateCreated'].toString())
        : (undefined as any)
      this.deviceName = _data['deviceName']
      this.isAdmin = _data['isAdmin']
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {}
    let result = new User()
    result.init(data)
    return result
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {}
    data['userId'] = this.userId
    data['loginName'] = this.loginName
    data['name'] = this.name
    data['surname'] = this.surname
    data['studentId'] = this.studentId
    data['teacherId'] = this.teacherId
    data['student'] = this.student ? this.student.toJSON() : (undefined as any)
    data['isStudent'] = this.isStudent
    data['teacher'] = this.teacher ? this.teacher.toJSON() : (undefined as any)
    data['isTeacher'] = this.isTeacher
    data['dateCreated'] = this.dateCreated ? this.dateCreated.toISOString() : (undefined as any)
    data['deviceName'] = this.deviceName
    data['isAdmin'] = this.isAdmin
    return data
  }
}

export interface IUser {
  userId?: number
  loginName?: string
  name?: string | undefined
  surname?: string | undefined
  studentId?: number | undefined
  teacherId?: number | undefined
  student?: Student
  isStudent?: boolean
  teacher?: Teacher
  isTeacher?: boolean
  dateCreated?: Date
  deviceName?: string | undefined
  isAdmin?: boolean
}

export class ApiException extends Error {
  override message: string
  status: number
  response: string
  headers: { [key: string]: any }
  result: any

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super()

    this.message = message
    this.status = status
    this.response = response
    this.headers = headers
    this.result = result
  }

  protected isApiException = true

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result
  else throw new ApiException(message, status, response, headers, null)
}
